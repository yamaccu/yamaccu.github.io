<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title />
		<link>https://yamaccu.github.io/</link>
		<description />
		<copyright>Copyright © 2021</copyright>
		<pubDate>Fri, 17 Sep 2021 14:43:41 GMT</pubDate>
		<lastBuildDate>Fri, 17 Sep 2021 14:43:41 GMT</lastBuildDate>
		<item>
			<title>WPFでBindingを使う</title>
			<link>https://yamaccu.github.io/posts/20210916-csharp-wpfbinding</link>
			<description>&lt;p&gt;WPFでBindingを使用する方法のまとめです。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210916-csharp-wpfbinding</guid>
			<pubDate>Thu, 16 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;WPFでBindingを使用する方法のまとめです。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;概要&lt;/h2&gt;
&lt;p&gt;WPFは、Windows上で動作するGUIアプリケーションを作成できるフレームワークです。&lt;br&gt;
ToDoリストを管理する、ボタンを押すとTCP/IPでデータを送信する、など様々なGUIアプリが作成可能です。&lt;br&gt;
画面はxaml、処理部はC#で作成します。&lt;/p&gt;
&lt;p&gt;WPFの特徴の一つとして「Bindingを使用した画面部と処理部の分離」があげられます。&lt;br&gt;
分離により管理が容易になったり、処理部でのテストが用意になったりといったメリットがあります。&lt;/p&gt;
&lt;p&gt;以降、WPFでBindingを使用する方法について記載しています。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-1"&gt;準備&lt;/h2&gt;
&lt;p&gt;開発環境はVisualStudioを使用します。&lt;br&gt;
VisualStudioのインストールおよびWPFのHello Worldまではこちらを参考にしてください。&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://docs.microsoft.com/ja-jp/visualstudio/get-started/csharp/tutorial-wpf?view=vs-2019"&gt;チュートリアル: C# で単純なアプリケーションを作成する&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="gui"&gt;今回作成したGUIアプリ&lt;/h2&gt;
&lt;p&gt;今回、Bindnigの確認用に、以下のアプリを作成しました。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字の0が初期値で表示されているテキストボックス&lt;/li&gt;
&lt;li&gt;数字を＋１するボタン&lt;/li&gt;
&lt;li&gt;数字を－１するボタン&lt;/li&gt;
&lt;/ul&gt;
&lt;img src="../img/20210916-Csharp-WPFBinding-1.png" style="width:100%;max-width:450px;"&gt;  
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;このアプリを、5つの実装方法で作成していきます。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Bindingなし（コードビハインドにべた書き）&lt;/li&gt;
&lt;li&gt;DataBindingを実装&lt;/li&gt;
&lt;li&gt;DataBindingとCommandBindingを実装&lt;/li&gt;
&lt;li&gt;CommandBindingを少しスマートに実装（Delegate使用）&lt;/li&gt;
&lt;li&gt;ReactivePropertyを使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;作ったアプリはGithubに上げています。&lt;br&gt;
&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://github.com/yamaccu/WPF-BindingSample"&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="binding"&gt;1. Bindingなし&lt;/h2&gt;
&lt;p&gt;コードビハインドに処理を記述します。&lt;br&gt;
コードビハインドとは、xaml.csファイルのことです。&lt;/p&gt;
&lt;img src="../img/20210916-Csharp-WPFBinding-2.png" style="width:100%;max-width:300px;"&gt;  
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;&lt;em&gt;MainWindow.xaml&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;&amp;lt;Button Content="1 UP" Click="OneUp_Click"/&amp;gt;
&amp;lt;Button Content="1 DOWN" Click="OneDown_Click"/&amp;gt;
&amp;lt;TextBox x:Name="Counter" Text="0" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;em&gt;MainWindow.xaml.cs(コードビハインド)&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;private void OneUp_Click(object sender, RoutedEventArgs e)
{
  var numValue = Convert.ToString(Convert.ToInt32(Counter.Text) + 1);
  Counter.Text = numValue;
}

private void OneDown_Click(object sender, RoutedEventArgs e)
{
  var numValue = Convert.ToString(Convert.ToInt32(Counter.Text) - 1);
  Counter.Text = numValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;これで完了です。&lt;br&gt;
これは直観的でわかりやすいかなと思います。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="databinding"&gt;2. DataBindingを実装&lt;/h2&gt;
&lt;p&gt;1から、TextBoxの数値をBindingに変更します。&lt;br&gt;
MainWindow.xaml（画面部）とViewModel.cs（処理部）の間でBindingします。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&amp;nbsp;&lt;img src="https://yamaccu.github.io/img/20210916-Csharp-WPFBinding-3.png" style="width:100%;max-width:450px;"&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id="datacontext"&gt;2-1. DataContextの設定&lt;/h3&gt;
&lt;p&gt;Bindingするためには、まずDataContextの設定が必要です。&lt;br&gt;
DataContextとは、画面部のコントロールのBinding値と処理部の変数を紐づけをしてくれるプロパティです。&lt;/p&gt;
&lt;p&gt;設定方法は、まずはViewModel.csというファイルを作成します。&lt;br&gt;
（作成するファイル名は何でもいいですが、MVVMモデルに沿ってViewModel.csという名前が良く使われます。）&lt;br&gt;
その後、MainWindow.xamlのデータコンテキストにViewModelを設定します。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&lt;em&gt;MainWindow.xaml.cs&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;ViewModel viewModel = new ViewModel();

public MainWindow()
{
  InitializeComponent();
  // データコンテキストの設定
  DataContext = viewModel;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id="xaml"&gt;2-2. xaml側のコード実装&lt;/h3&gt;
&lt;p&gt;TextBoxのTextに変数をBindigします。&lt;br&gt;
ここでは、"Counter"という名前の変数とします。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MainWindow.xaml&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;&amp;lt;TextBox Text="{Binding Counter}"/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;h3 id="viewmodel"&gt;2-3. ViewModel側のコード実装&lt;/h3&gt;
&lt;p&gt;Bindingした変数と同じ"Counter"という名前の変数を宣言します。&lt;/p&gt;
&lt;p&gt;次に、ViewModelBaseクラスを作成します。&lt;br&gt;
これは最初は、必ずコピペする定型処理、と覚えてしまって大丈夫です。&lt;/p&gt;
&lt;p&gt;ViewModelクラスにViewModelBaseクラスを継承して、変数"Counter"のSetterに”RaisePropertyChanged("Counter")”を入れます。&lt;br&gt;
これで、"Counter"の値が変更になったときに、変更をxaml側に反映できるようになります。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ViewModel.cs&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public class ViewModel : ViewModelBase
{
  private string counter = "0";
  public string Counter
  {
    get { return counter; }
    set
    {
      counter = value;
      RaisePropertyChanged("Counter");
    }
  }
}

public class ViewModelBase : INotifyPropertyChanged
{
  public event PropertyChangedEventHandler PropertyChanged;
  protected virtual void RaisePropertyChanged(string propertyName)
  {
    var h = this.PropertyChanged;
    if (h != null)
      {
        h(this, new PropertyChangedEventArgs(propertyName));
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;以上で、DataBindingは完了です。&lt;br&gt;
ViewModel.csの"Counter"の値が変わると、画面のTextboxの数値も変更されるようになりました。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;※ 変数"Counter"をViewModel.csの方で宣言しているので、
クリックイベントの処理もViewModel.csの方へ移しておきます。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MainWindow.xml.cs（コードビハインド）&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;private void OneUp_Click(object sender, RoutedEventArgs e)
{
  viewModel.OneUp();
}

private void OneDown_Click(object sender, RoutedEventArgs e)
{
  viewModel.OneDown();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;&lt;em&gt;ViewModel.cs&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public void OneUp()
{
  var numValue = (Convert.ToString(Convert.ToInt32(Counter) + 1));
  Counter = numValue;
}

public void OneDown()
{
  var numValue = (Convert.ToString(Convert.ToInt32(Counter) - 1));
  Counter = numValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="databindingcommandbinding"&gt;3. DataBindingとCommandBindingを実装&lt;/h2&gt;
&lt;p&gt;2から、ボタンをクリックしたときのイベント処理もBindingに変更します。&lt;br&gt;
CommandBindingもDataContextの設定は必須です。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&amp;nbsp;&lt;img src="https://yamaccu.github.io/img/20210916-Csharp-WPFBinding-4.png" style="width:100%;max-width:450px;"&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id="icommand"&gt;3-1. ICommandについて&lt;/h3&gt;
&lt;p&gt;CommandBindingにはICommandインターフェースを使用します。&lt;br&gt;
これでないと画面部と処理部の間をBindingできません。&lt;/p&gt;
&lt;p&gt;ICommandインターフェースは3つのメンバがいます。&lt;br&gt;
継承先クラスにはこれらを実装する必要があります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public interface ICommand
{
  event EventHandler CanExecuteChanged;
  bool CanExecute(object parameter);
  void Execute(object parameter);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Executeメソッド：コマンド実行&lt;/li&gt;
&lt;li&gt;CanExecuteメソッド：コマンドの実行可否の状態&lt;/li&gt;
&lt;li&gt;CanExecuteChangedイベント：コマンドの実行状態が変化したことを通知するイベント&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h3 id="xaml-1"&gt;3-2. xaml側のコード実装&lt;/h3&gt;
&lt;p&gt;ボタンのClickイベントは削除して、Commandプロパティに変数をBindingします。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MainWindow.xaml&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;&amp;lt;Button Content="1 UP" Command="{Binding OneUpCommand}" /&amp;gt;
&amp;lt;Button Content="1 DOWN" Command="{Binding OneDownCommand}"/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id="viewmodel-1"&gt;3-2. ViewModel側のコード実装&lt;/h3&gt;
&lt;p&gt;ICommandで変数を宣言します。&lt;br&gt;
その後、コンストラクタでICommand変数に処理を登録します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public ICommand OneUpCommand { get; set; }
public ICommand OneDownCommand { get; set; }

public ViewModel()
{
  OneUpCommand = new OneUpCommandImpl(this);
  OneDownCommand = new OneDownCommandImpl(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;処理の実態のコード（上でいうOneUpCommandImpl）には、ICommandを継承します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public class OneUpCommandImpl : ICommand
{
  public OneUpCommandImpl(ViewModel viewmodel)
  {
    vm = viewmodel;
  }
  private ViewModel vm;
  public bool CanExecute(object parameter)
  {
    return true;
  }
  public event EventHandler CanExecuteChanged;

  //処理の実体
  public void Execute(object parameter)
  {
    vm.OneUp();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;OneDownの方も同じように記述します。&lt;br&gt;
これで、画面部のボタンをクリックするとOneUp/OneDownの処理が実行されるようになりました。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="commandbindingdelegate"&gt;4. CommandBindingを少しスマートに実装（Delegate使用）&lt;/h2&gt;
&lt;p&gt;3は、CommandBindingごとにICommandインターフェースを実装しないといけないので、コード量が増えてくると煩雑になります。&lt;br&gt;
デリゲードを使用することで少しすっきり記述することができます。&lt;/p&gt;
&lt;p&gt;下記のようなICommandを継承したCommandクラスを作成します。&lt;br&gt;
作ったCommandクラスの中にActionデリゲードがあって、インスタンス化時にActionに処理を登録するようにします。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public class Command : ICommand
{
  private Action execute;
  private bool canExecute = true;

  public Command(Action execute)
  {
    this.execute = execute;
  }

  public void Execute(object parameter)
  {
    execute();
  }

  public bool CanExecute(object parameter)
  {
    return canExecute;
  }

  public void SetCanExecute(bool canExecute)
  {
    this.canExecute = canExecute;
    if (CanExecuteChanged != null)
    {
      CanExecuteChanged(this, EventArgs.Empty);
    }
  }

  public event EventHandler CanExecuteChanged;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;ViewModelのコンストラクタは以下のようになります。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public ViewModel()
{
  OneUpCommand = new Command(OneUp);
  OneDownCommand = new Command(OneDown);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;これで、画面部のボタンをクリックするとOneUp/OneDownの処理が実行されます。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="reactiveproperty"&gt;5. ReactivePropertyを使用&lt;/h2&gt;
&lt;p&gt;ReactivePropertyとは、Bindingを補佐してくれるライブラリです。&lt;br&gt;
nugetからインストール可能です。&lt;br&gt;
2~4で記載してきたBindingのコードを大幅に削減することができます。&lt;/p&gt;
&lt;p&gt;以下のリンクも参考にしてください。&lt;/p&gt;
&lt;p&gt;参考1&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://github.com/runceel/ReactiveProperty"&gt;公式&lt;/a&gt;&lt;br&gt;
参考2&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://qiita.com/YSRKEN/items/5a36fb8071104a989fb8"&gt;qiita ReactiveProperty全然分からねぇ！って人向けのFAQ集&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id="section-2"&gt;5-1. メモリリーク対策&lt;/h3&gt;
&lt;p&gt;PropertyChangedを実装しないと、ViewModelが破棄されずにメモリリークするとのことです。&lt;br&gt;
以下のコードは必ず実行してください。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;class ViewModel : INotifyPropertyChanged
{
  public event PropertyChangedEventHandler PropertyChanged;
　　・・・
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://aridai.net/articles/15.html"&gt;【WPF】ViewModelがINotifyPropertyChangedを実装していないとメモリリークする件&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h3 id="databinding-1"&gt;5-2. DataBinding&lt;/h3&gt;
&lt;p&gt;変数"Counter"は以下のように宣言します。&lt;br&gt;
RaisePropertyChangedは不要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public ReactiveProperty&amp;lt;string&amp;gt; Counter { get; set; } = new ReactiveProperty&amp;lt;string&amp;gt;("0");
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;"Counter"の値を変更するには、Valueプロパティに値を入れます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;private void OneUp()
{
  var numValue = (Convert.ToString(Convert.ToInt32(Counter.Value) + 1));
  Counter.Value = numValue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;これで、"Couter"の値の変更が画面に反映されるようになりました。&lt;br&gt;
とてもシンプルになります。&lt;/p&gt;
&lt;br&gt;
&lt;h3 id="commandbinding"&gt;5-3. CommandBinding&lt;/h3&gt;
&lt;p&gt;Commandは以下のように宣言します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public ReactiveCommand OneUpCommand { get; set; } = new ReactiveCommand();
public ReactiveCommand OneDownCommand { get; set; } = new ReactiveCommand();
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;処理の登録は、下記のようにします。&lt;br&gt;
Subscribeに処理を登録することで、ボタンを押したときに登録した処理が実行されるようになります。&lt;br&gt;
ICommandとか不要です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public ViewModel()
{
  OneUpCommand.Subscribe(_ =&amp;gt; OneUp());
  OneDownCommand.Subscribe(_ =&amp;gt; OneDown());
}

&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;これで、ボタンを押したときに処理が実行されるようになりました。&lt;br&gt;
こちらもとてもシンプルです。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-3"&gt;終わりに&lt;/h2&gt;
&lt;p&gt;1~5のサンプルを見て、実は1のコードビハインドに書くやり方が最もシンプルかつ直観的でわかりやすいと感じるかと思います。&lt;br&gt;
しかし、少し複雑なアプリになってくると、画面部と処理部を分離した方が可読性がよく、修正もしやすくなってきます。&lt;/p&gt;
&lt;p&gt;ササっと簡単なアプリを作る際はコードビハインドを使ってしまうことがありますが、なるべくReactivePropetyを使ってBindingしていく方が長い目で見たときに良い結果になるかと思います。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;以上になります。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Github Pagesにコメント欄を追加する</title>
			<link>https://yamaccu.github.io/posts/20210907-githubpages-utterances</link>
			<description>&lt;p&gt;Github PagesにGitHub App「utterances」を使ってコメント欄を追加する方法です。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210907-githubpages-utterances</guid>
			<pubDate>Tue, 07 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Github PagesにGitHub App「utterances」を使ってコメント欄を追加する方法です。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;概要&lt;/h2&gt;
&lt;p&gt;Githubには、Github Pagesという静的サイトを公開する機能があります。&lt;br /&gt;
&amp;lt;username&amp;gt;.github.ioというレポジトリを作成して、index.htmlを放り込むと、以下のURLアドレスに公開されます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  https://&amp;lt;username&amp;gt;.github.io/
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;詳細は以下の公式HPを参照ください。&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages"&gt;GitHub Pagesについて&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;静的サイトにコメント欄を追加する場合、動的要素であるコメント欄を静的サイトに実装することができないため、通常は外部サーバーサービスなどを利用します。&lt;br /&gt;
ただし、Github Pagesにおいては、Issueを利用してコメント欄を追加する「utterances」というオープンソースのツールがあります。&lt;br /&gt;
コメントするにはgithubにログインする必要がありますが、手軽にコメント欄を追加できるのと、エンジニアはgithub IDをすでに持っていることが多いことから、技術ブログには最適な選択となっています。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;以下、「utterances」の使用方法について記述しています。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-1"&gt;準備&lt;/h2&gt;
&lt;p&gt;Github Pagesを公開している必要があります。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="utterances-app"&gt;utterances appのインストール&lt;/h2&gt;
&lt;p&gt;サイトを公開しているGithubレポジトリにutterances appをインストールします。&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://github.com/apps/utterances"&gt;utterances app&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;インストールすると、GithubのSetting → Applicationsにutterancesが表示されます。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="script"&gt;scriptの埋め込み&lt;/h2&gt;
&lt;p&gt;HTMLソースのコメント欄を追加したい箇所に、utterancesのスクリプトを埋め込みます。&lt;br /&gt;
スクリプトは下記のページで生成できます。&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://utteranc.es/"&gt;utterances&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;そうすると、下記のようなコメント欄が表示されます。&lt;br /&gt;
これで完成です。&lt;/p&gt;
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Resharperのコマンドラインツールを使う</title>
			<link>https://yamaccu.github.io/posts/20210903-csharp-resharpercommand</link>
			<description>&lt;p&gt;C#の開発支援ツールであるResharperのコマンドラインツールのまとめです。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210903-csharp-resharpercommand</guid>
			<pubDate>Fri, 03 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;C#の開発支援ツールであるResharperのコマンドラインツールのまとめです。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;概要&lt;/h2&gt;
&lt;p&gt;Resharperとは、JetBrains社が販売しているC#開発支援ツールです。&lt;br /&gt;
Visual Studio向けのアドオンと、コマンドラインで実行できるコマンドラインツールがあります。&lt;/p&gt;
&lt;p&gt;Visual Studio向けのアドオンは基本有料で、コーディングのヒントや、ネーミング規則に違反した箇所の指摘などをアクティブに実施してくれます。&lt;/p&gt;
&lt;p&gt;コマンドラインツールは無料で、コードを静的に解析するものです。&lt;br /&gt;
コードレビュー等に有用です。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;本記事では、無料のコマンドラインツールについてまとめています。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-1"&gt;準備&lt;/h2&gt;
&lt;p&gt;Resharper公式から、コマンドラインツールをダウンロードしておきます。&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://www.jetbrains.com/ja-jp/resharper/download/#section=commandline"&gt;ダウンロード先&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-2"&gt;コマンドラインツールの3つの機能&lt;/h2&gt;
&lt;p&gt;Resharperのコマンドラインツールには3つの機能があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CleanupCode：コードの整形&lt;/li&gt;
&lt;li&gt;dupFinder  ：コードの重複の検出&lt;/li&gt;
&lt;li&gt;InspectCode：コードの検査&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="cleanupcode"&gt;CleanupCode&lt;/h2&gt;
&lt;p&gt;インデントの修正、修飾子の修正、不要Usingディレクティブの削除など、コードの可読性を改善してくれます。&lt;/p&gt;
&lt;p&gt;実行コマンド&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;cleanupcode.exe YourSolution.sln
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;既存のファイルに修正結果が上書きされますので、実行時は注意してください。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;公式doc日本語訳&lt;br /&gt;
&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://pleiades.io/help/resharper/CleanupCode.html"&gt;CleanupCodeコマンドラインツール&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="dupfinder"&gt;dupFinder&lt;/h2&gt;
&lt;p&gt;コードの重複を調べてレポートファイルをxml形式で出力してくれます。&lt;/p&gt;
&lt;p&gt;実行コマンド&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;dupFinder.exe &amp;lt;source&amp;gt; --output=&amp;lt;FileName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;レポートに重複コードまで含める場合の実行コマンド&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;dupFinder.exe &amp;lt;source&amp;gt; --output=&amp;lt;FileName&amp;gt; --show-text
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;レポートファイルは下記のような感じです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;statistics：重複コードの相対サイズがわかります。&lt;/li&gt;
&lt;li&gt;duplicates：重複箇所を示します。&lt;/li&gt;
&lt;/ul&gt;
&lt;img src="../img/20210903-Csharp-ResharperCommand-1.png" Style="width:100%;max-width:550px;"&gt;  
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;公式doc日本語訳&lt;br /&gt;
&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://pleiades.io/help/resharper/dupFinder.html"&gt;dupFinderコマンドラインツール&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="inspectcode"&gt;InspectCode&lt;/h2&gt;
&lt;p&gt;コードを解析して、結果をxml形式で出力してくれます。&lt;/p&gt;
&lt;p&gt;実行コマンド&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;InspectCode.exe YourSolution.sln --output=&amp;lt;FileName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;レポートファイルは下記のような感じです。&lt;br /&gt;
(小さくて見えづらいかもしれません)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeId：指摘のカテゴリ&lt;/li&gt;
&lt;li&gt;Message：指摘詳細&lt;/li&gt;
&lt;li&gt;File/Offset/Line：指摘の場所&lt;/li&gt;
&lt;/ul&gt;
&lt;img src="../img/20210903-Csharp-ResharperCommand-2.png" Style="width:100%;max-width:750px;"&gt;  
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;例えば、「TypeId：InconsistentNaming」は、ネーミングルール違反を教えてくれています。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;公式doc日本語訳&lt;br /&gt;
&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://pleiades.io/help/resharper/InspectCode.html"&gt;InspectCodeコマンドラインツール &lt;/a&gt;&lt;br /&gt;
&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://pleiades.io/help/resharper/Reference__Code_Inspections_CSHARP.html"&gt;C# のコードインスペクション&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>VSCodeの拡張機能「Markdown All in One」を使う</title>
			<link>https://yamaccu.github.io/posts/20210830-markdown-allinone</link>
			<description>&lt;p&gt;VSCodeの拡張機能である「Markdown All in One」の機能まとめです。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210830-markdown-allinone</guid>
			<pubDate>Mon, 30 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;VSCodeの拡張機能である「Markdown All in One」の機能まとめです。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;概要&lt;/h2&gt;
&lt;p&gt;VSCodeとは、Microsoft社が開発している無料のコードエディターです。&lt;br&gt;
カスタマイズ性が高く、様々な拡張機能をインストール可能なのが特徴です。&lt;br&gt;
今、最もよく使われているエディターです。&lt;/p&gt;
&lt;p&gt;本記事では、MarkDownを書くのに便利な拡張機能「Markdown All in One」の機能をまとめています。&lt;/p&gt;
&lt;p&gt;Markdownの記法メモはこちらにまとめています。&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt;
&lt;a href="https://yamaccu.github.io/posts/20210816-markdown-tips"&gt;MarkDown記法のメモ&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-1"&gt;準備&lt;/h2&gt;
&lt;p&gt;VSCodeと、拡張機能の「Markdown All in One」をPCにインストールします。&lt;br&gt;
拡張機能は、VSCodeを開いたら左側の四角形が四つあるアイコンからインストールできます。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;img src="https://yamaccu.github.io/img/20210830-MarkDown-AllInOne-1.png" width="40px"&gt;
← こんなアイコン&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;参考 &lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://azure.microsoft.com/ja-jp/products/visual-studio-code/"&gt;VSCode公式&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-2"&gt;ショートカット機能&lt;/h2&gt;
&lt;br&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キーボード操作&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctr+B&lt;/td&gt;
&lt;td&gt;太字 (**)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctr+I&lt;/td&gt;
&lt;td&gt;イタリック(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctr+Shift+]&lt;/td&gt;
&lt;td&gt;見出し(#)、実行ごとに#が増える&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctr+Shift+[&lt;/td&gt;
&lt;td&gt;見出し(#)、実行ごと#が減る&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctr+M&lt;/td&gt;
&lt;td&gt;数式挿入($)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt+C&lt;/td&gt;
&lt;td&gt;チェックボックスのON（[x]）、もう一度押すと解除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt+S&lt;/td&gt;
&lt;td&gt;取り消し(~~)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt+Shift+F&lt;/td&gt;
&lt;td&gt;表の表記のフォーマット整形&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;p&gt;以下はもともとVSCodeに入っており便利なショートカット&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キーボード操作&lt;/th&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctr+K → v&lt;/td&gt;
&lt;td&gt;サイドにプレビュー表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctr+shift+v&lt;/td&gt;
&lt;td&gt;タブにプレビュー表示&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-3"&gt;目次の自動作成&lt;/h2&gt;
&lt;p&gt;見出し(#)の目次を自動で作成してくれます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自動作成：Ctr+Shift+p → Markdown All in One: Create Table of Contents&lt;/li&gt;
&lt;li&gt;更新　　：Ctr+Shift+p → Markdown All in One: Update Table of Contents&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;↓こんな感じです。&lt;br&gt;
&lt;img src="https://yamaccu.github.io/img/20210830-MarkDown-AllInOne-2.png" style="width:100%;max-width:450px;"&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;また、見出しに自動で番号を振ってくれます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;番号追加：Ctr+Shift+p → MarkDown All in One: Add/Update section numbers&lt;/li&gt;
&lt;li&gt;番号削除：Ctr+Shift+p → MarkDown All in One: Remove section numbers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;↓こんな感じです。&lt;br&gt;
&lt;img src="https://yamaccu.github.io/img/20210830-MarkDown-AllInOne-3.png" style="width:100%;max-width:450px;"&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;目次に入れたくない見出しがある場合は、見出しの前の行に「&amp;lt;!-- omit in toc --&amp;gt;」を追加します。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-4"&gt;リストの入力補佐&lt;/h2&gt;
&lt;p&gt;- や1. などのリストを作成しているときに、行追加時に自動でリストが追加されます。&lt;br&gt;
また、tabでインデントされます。&lt;br&gt;
地味に便利なやつです。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="html"&gt;HTML出力&lt;/h2&gt;
&lt;p&gt;現在開いているMarkDownファイルをHTMLへ変換できます。&lt;br&gt;
Ctr+Shift+p → Markdown All in One: Print current document to HTML&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-5"&gt;リンクの作成&lt;/h2&gt;
&lt;p&gt;HPなどのアドレスをコピーした状態で、テキストを選択してCtr+Vすると、リンクを自動作成してくれます。&lt;/p&gt;
&lt;img src="../img/20210830-MarkDown-AllInOne-4.png" style="width:100%;max-width:350px;"&gt;  
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>C#でシリアル通信</title>
			<link>https://yamaccu.github.io/posts/20210825-csharp-serialport</link>
			<description>&lt;p&gt;C#でシリアル通信を行う方法をまとめています。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210825-csharp-serialport</guid>
			<pubDate>Wed, 25 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;C#でシリアル通信を行う方法をまとめています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;概要&lt;/h2&gt;
&lt;h3 id="section-1"&gt;シリアル通信について&lt;/h3&gt;
&lt;p&gt;シリアル通信とは、機器間で通信する方法の一つで、データを1bitづつ送信する形式のものです。&lt;br&gt;
代表的な規格はRC-232です。&lt;br&gt;
PCとマイコンボード（arduinoなど）間で通信するのによく使われています。&lt;/p&gt;
&lt;p&gt;C#には、シリアル通信を行うクラスがすでに用意されています。&lt;br&gt;
これを使うと簡単にシリアル通信ができます。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;&amp;nbsp;&lt;img src="https://yamaccu.github.io/img/20210825-Csharp-SerialPort-1.png" style="width:100%;max-width:450px;"&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h3 id="wpf"&gt;WPFアプリ作成について&lt;/h3&gt;
&lt;p&gt;今回、シリアル通信をするGUIアプリをWPFで作ってみました。&lt;br&gt;
&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://github.com/yamaccu/WPF-SerialCommunication/tree/main"&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;img src="https://yamaccu.github.io/img/20210825-Csharp-SerialPort-2.png" style="width:100%;max-width:400px;"&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;アプリ作成にあたってReactivePropertyというライブラリを使用しています。&lt;br&gt;
データバインディングを補佐してくれるもので、大量のINotifyPropertyChangedを実施しなくて済むようになるのでお勧めです。&lt;/p&gt;
&lt;p&gt;また、ReactivePropertyはコマンドバインディングも対応していますが、こちらは今回のアプリでは使用していません。&lt;br&gt;
正直、規模の小さなアプリではコマンドバインディングするよりコードビハインドにイベント処理を書いてしまった方がシンプルで可読性が良いかと思います。&lt;br&gt;
（異論はありそうですが。。）&lt;/p&gt;
&lt;p&gt;参考1&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://github.com/runceel/ReactiveProperty"&gt;公式&lt;/a&gt;&lt;br&gt;
参考2&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://qiita.com/YSRKEN/items/5a36fb8071104a989fb8"&gt;qiita ReactiveProperty全然分からねぇ！って人向けのFAQ集&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p&gt;以下、作ったアプリの説明になります。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="class"&gt;使用Class&lt;/h2&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.ports.serialport?view=dotnet-plat-ext-5.0"&gt;SerialPort class&lt;/a&gt;を使用します。&lt;br&gt;
NugetでSystem.IO.Portsをインストールすると使えるようになります。&lt;br&gt;
複数ポートを同時に使用しない場合は、staticで宣言することが多いようです。&lt;/p&gt;
&lt;p&gt;使用するメソッドは下記です。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;機能&lt;/th&gt;
&lt;th&gt;メソッド&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;使用可能ポート取得&lt;/td&gt;
&lt;td&gt;GetPortNames()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;シリアルポートオープン&lt;/td&gt;
&lt;td&gt;Open()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;シリアルポートクローズ&lt;/td&gt;
&lt;td&gt;Close()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;データ送信&lt;/td&gt;
&lt;td&gt;Write(string)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;データ受信&lt;/td&gt;
&lt;td&gt;ReadExisting()&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-2"&gt;使用可能なポートの取得&lt;/h2&gt;
&lt;p&gt;以下は、使用可能なCOMポートを取得し、アプリ画面のComboBoxに取得データをbindingするコードです。&lt;/p&gt;
&lt;p&gt;ViewModel.cs：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;//DataBindig用変数
public ReactiveCollection&amp;lt;string&amp;gt; COMPorts { get; set; }
      = new ReactiveCollection&amp;lt;string&amp;gt;(); 

public void GetCOMPorts()
{
  COMPorts.Clear();
  string[] ports = SerialPort.GetPortNames();
  foreach (var port in ports)
  {
    COMPorts.Add(port);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MainWindow.xaml：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;&amp;lt;ComboBox ItemsSource="{Binding COMPorts}" /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;COMポートを取得するメソッドは、ComboBoxのDropDownOpenedイベントに登録しておくと、ドロップダウンを開く度に使用可能ポートを更新してくれて便利です。&lt;/p&gt;
&lt;p&gt;MainWindow.xaml:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;&amp;lt;ComboBox DropDownOpened="ComboBoxDropDownOpened_COMPort"/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MainWindow.xaml.cs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;private void ComboBoxDropDownOpened_COMPort(object sender, EventArgs e)
{
  viewModel.GetCOMPorts();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-3"&gt;シリアルポートのオープン&lt;/h2&gt;
&lt;p&gt;シリアルポート通信の各種設定をしたのち、接続をOpenします。&lt;br&gt;
コードは以下です。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public void SerialOpen()
{
  try
  {
    serialPort.PortName = port;        //選択したport名
    serialPort.BaudRate = baudrate;    //選択したbaudrate
    serialPort.DataBits = 8;
    serialPort.Parity = Parity.None;
    serialPort.StopBits = StopBits.One;
    serialPort.WriteTimeout = 1000;
    serialPort.ReadTimeout = 1000;
    serialPort.Encoding=Encoding.UTF8;
    serialPort.Open();
  }
  catch (Exception ex)
  {
    MessageBox.Show(ex.Message);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-4"&gt;シリアルポートのクローズ&lt;/h2&gt;
&lt;p&gt;シリアルポート接続をCloseします。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public void SerialClose()
{
  try
  {
    serialPort.Close();
  }
  catch (Exception ex)
  {
    MessageBox.Show(ex.Message);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-5"&gt;データの送信&lt;/h2&gt;
&lt;p&gt;文字列を送信します。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public void Send()
{
  if (serialPort.IsOpen)
  {
    serialPort.Write(TXData);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-6"&gt;データの受信&lt;/h2&gt;
&lt;p&gt;文字列を受信します。&lt;br&gt;
受信データの取り出しは、割込みを使って行います。&lt;br&gt;
データを受信したらすぐにデータを取り込んでくれます。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;SerialCom.serialPort.DataReceived += OnReceived;

private void OnReceived(object sender, SerialDataReceivedEventArgs e)
{
  RXData += serialPort.ReadExisting();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-7"&gt;動作確認のためのシリアル通信折り返し方法&lt;/h2&gt;
&lt;p&gt;シリアル通信で送信したデータを折り返してそのまま受信すると、送信と受信の確認を同時にできて効率的です。&lt;br&gt;
以下のUSB-シリアル変換を使用すれば確認可能です。&lt;br&gt;
TxピンとRxピンを導線で繋いで動作確認します。&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://akizukidenshi.com/catalog/g/gM-11007/"&gt;秋月電子 FT-232RQ USBシリアル変換モジュール&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;Arduinoなどが手元にあれば、折り返しするようプログラミングしても良いですね。&lt;/p&gt;
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>M5Stack UIFLOWでカスタムブロックを作る</title>
			<link>https://yamaccu.github.io/posts/20210823-uiflow-customblock</link>
			<description>&lt;p&gt;M5Stack向けのVisual Programming「UIFLOW」で、カスタムブロックを作成する方法をまとめました。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210823-uiflow-customblock</guid>
			<pubDate>Mon, 23 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;M5Stack向けのVisual Programming「UIFLOW」で、カスタムブロックを作成する方法をまとめました。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;概要&lt;/h2&gt;
&lt;p&gt;&amp;nbsp;&lt;img src="https://yamaccu.github.io/img/20210823-UIFLOW-CustomBlock-1.png" width="65px"&gt;
← M5Stackはこんなやつ。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;M5Stackとは、ESP32を使用しwifi/LCD/各種センサなどを一体化させた、使いやすいマイコンボードです。&lt;br&gt;
LCDが標準装備なのが一番の特徴かと思います。&lt;br&gt;
センシングした値を表示させたり、顔をつけてみたりと、いろいろ遊べます。&lt;/p&gt;
&lt;p&gt;参考&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://m5stack.com/"&gt;公式HP&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;UIFLOWとは、M5Stackのプログラミング環境の一つで、スクラッチのようにビジュアルプログラミングでM5Stackのコードが書ける優れものです。&lt;br&gt;
更にwebベースでプログラミングできるので、プログラム環境の準備がお手軽です。&lt;br&gt;
大本はmicropythonで動いています。&lt;br&gt;
使い方、プログラミングの仕方などは下記のHPを参照ください。&lt;/p&gt;
&lt;p&gt;参考1&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://m5stack.github.io/UIFlow_doc/ja/"&gt;公式HP&lt;/a&gt;&lt;br&gt;
参考2&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://flow.m5stack.com/"&gt;プログラミングページ&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;UIFLOWでは、事前に用意されたブロックを組み合わせてプログラミングしますので、ブロックに用意されていない機能は、自分でカスタムブロックを作る必要があります。&lt;/p&gt;
&lt;p&gt;以降、UIFLOWでカスタムブロックを作成する方法を記載しています。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-1"&gt;カスタムブロックのサンプル&lt;/h2&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://github.com/yamaccu/UIFLOW-wavplayer"&gt;github&lt;/a&gt;にWAVファイルを再生するためのカスタムブロックをあげていますので、よろしければ参考にしてください。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-2"&gt;カスタムブロックの作成手順&lt;/h2&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="http://block-maker.m5stack.com/"&gt;こちらのカスタムブロック作成ページ&lt;/a&gt;から作成します。&lt;/p&gt;
&lt;p&gt;作成手順は&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pythonでプログラムを書く&lt;/li&gt;
&lt;li&gt;初期設定用のブロックを作る&lt;/li&gt;
&lt;li&gt;関数を実行するブロックを作る&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="python"&gt;1. Pythonでプログラムを書く&lt;/h2&gt;
&lt;p&gt;まずはブロック化したい機能のプログラムをpythonで書きます。&lt;br&gt;
処理は関数にして呼び出しできるようにしておきます。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-3"&gt;2. 初期設定用のブロックを作る&lt;/h2&gt;
&lt;p&gt;import、defを行うブロックを作成します。&lt;br&gt;
このブロックは最初のsetupで実行するものです。&lt;/p&gt;
&lt;br&gt;
&lt;div style="display:flex;flex-wrap:wrap"&gt;
&lt;div&gt;
&lt;img src="https://yamaccu.github.io/img/20210823-UIFLOW-CustomBlock-2.png" style="width:100%;max-width:420px;margin-right:5px;"&gt;  
&lt;br&gt;
&lt;br&gt;
&lt;/div&gt;
&lt;div style="max-width:450px;"&gt;
&lt;ol&gt;
&lt;li&gt;NameSpace：Blockmaker上だけの識別名なので何でもOK&lt;/li&gt;
&lt;li&gt;BlockColor：ブロックの色を設定&lt;/li&gt;
&lt;li&gt;Add Block/Remove Block：ブロックの追加・削除&lt;/li&gt;
&lt;li&gt;Type：Executeにする&lt;/li&gt;
&lt;li&gt;Parameter：まずブロック名をtype:Labelで設定する&lt;br&gt;
変数があれば、type:String/Number/Variableで設定する&lt;/li&gt;
&lt;li&gt;BlockCode：作ったプログラムをコピペ&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-4"&gt;3. 関数を実行するブロックを作る&lt;/h2&gt;
&lt;p&gt;defで定義した関数を実行するブロックを作ります。&lt;br&gt;
Add Blockをクリックするとブロックが増えますので、設定していきます。&lt;br&gt;
引数がある場合は、parameterで設定します。&lt;/p&gt;
&lt;br&gt;
&lt;div style="display:flex;flex-wrap:wrap"&gt;
&lt;div&gt;
&lt;img src="https://yamaccu.github.io/img/20210823-UIFLOW-CustomBlock-3.png" style="width:100%;max-width:420px;margin-right:5px;"&gt;  
&lt;br&gt;
&lt;br&gt;
&lt;/div&gt;
&lt;div style="max-width:450px;"&gt;
&lt;ol&gt;
&lt;li&gt;NameSpace：Blockmaker上だけの識別名なので何でもOK&lt;/li&gt;
&lt;li&gt;BlockColor：ブロックの色を設定&lt;/li&gt;
&lt;li&gt;Add Block/Remove Block：ブロックの追加・削除&lt;/li&gt;
&lt;li&gt;Type：Executeにする&lt;/li&gt;
&lt;li&gt;Parameter：まずブロック名をtype:Labelで設定する&lt;br&gt;
変数があれば、type:String/Number/Variableで設定する&lt;/li&gt;
&lt;li&gt;BlockCode：自作関数の呼び出しを行う&lt;br&gt;
引数は上記のParameterで設定して、&lt;br&gt;
BlockCode内で"$(hoge)"の形で記述する&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ex)playwav(${playwav},${volume})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-5"&gt;完成したら&lt;/h2&gt;
&lt;p&gt;ページ右下のDownloadボタンをおして、DownloadファイルをUIFLOWの&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://flow.m5stack.com/"&gt;プログラミングページ&lt;/a&gt;のCustomから開きます。&lt;br&gt;
そうすると、UIFLOWで自作のカスタムブロックが使用できるようになります。&lt;/p&gt;
&lt;img src="../img/20210823-UIFLOW-CustomBlock-4.png" style="width:100%;max-width:150px"&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img src="../img/20210823-UIFLOW-CustomBlock-5.png" style="width:100%;max-width:450px"&gt;  
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>HTML div要素で図形を表示する</title>
			<link>https://yamaccu.github.io/posts/20210821-html-figure</link>
			<description>&lt;p&gt;HTMLのdiv要素を使って、ブラウザに図形を表示させる方法です。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210821-html-figure</guid>
			<pubDate>Sat, 21 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;HTMLのdiv要素を使って、ブラウザに図形を表示させる方法です。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;図形の作成方法&lt;/h2&gt;
&lt;p&gt;div要素のサイズを指定して、色を付けてあげれば図形になります。&lt;br /&gt;
試しに丸と四角を作ってみます。&lt;/p&gt;
&lt;br&gt;
&lt;p class="codepen" data-height="300" data-default-tab="result" data-slug-hash="KKWyajK" data-user="yy87750722" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;"&gt;
  &lt;span&gt;See the Pen &lt;a href="https://codepen.io/yy87750722/pen/KKWyajK"&gt;
  &lt;/a&gt; by やまっく (&lt;a href="https://codepen.io/yy87750722"&gt;&amp;#64;yy87750722&lt;/a&gt;)
  on &lt;a href="https://codepen.io"&gt;CodePen&lt;/a&gt;.&lt;/span&gt;
&lt;/p&gt;
&lt;script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"&gt;&lt;/script&gt;
&lt;br&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;div class=&amp;quot;square&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;circle&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSS"&gt;.square {
  width: 50px;
  height: 50px;
  background: black;
}
.circle {
  width: 50px;
  height: 50px;
  background: black;
  border-radius: 50px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-1"&gt;複雑な形の図形&lt;/h2&gt;
&lt;p&gt;疑似要素（before / after）を使います。&lt;br /&gt;
疑似要素とは、HTMLの要素に対して、CSSで要素を追記できる方法です。&lt;br /&gt;
これを使えば、作った図形に2つまで図形の追加ができます。&lt;br /&gt;
（合計3つの図形を一つのDiv内に作れる）&lt;/p&gt;
&lt;p&gt;以下のようなマークを作ってみます。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;時計マーク&lt;/li&gt;
&lt;li&gt;位置マーク&lt;/li&gt;
&lt;li&gt;虫眼鏡マーク&lt;/li&gt;
&lt;li&gt;スイッチマーク&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p class="codepen" data-height="300" data-default-tab="result" data-slug-hash="Vwboydb" data-user="yy87750722" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;"&gt;
  &lt;span&gt;See the Pen &lt;a href="https://codepen.io/yy87750722/pen/Vwboydb"&gt;
  &lt;/a&gt; by やまっく (&lt;a href="https://codepen.io/yy87750722"&gt;&amp;#64;yy87750722&lt;/a&gt;)
  on &lt;a href="https://codepen.io"&gt;CodePen&lt;/a&gt;.&lt;/span&gt;
&lt;/p&gt;
&lt;script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"&gt;&lt;/script&gt;
&lt;br&gt;
&lt;p&gt;■時計マーク&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;div class=&amp;quot;clock&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSS"&gt;.clock {
  display: inline-block;
  position: relative;
  width: 20px;
  height: 20px;
  border: 2px solid dimgray;
  border-radius: 20px;
}
.clock:before {
  content: &amp;quot;&amp;quot;;
  position: absolute;
  width: 7px;
  height: 9px;
  border-left: 2px solid dimgray;
  border-bottom: 2px solid dimgray;
  top: 2px;
  left: 6px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;■位置マーク&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;div class=&amp;quot;location&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSS"&gt;.location {
  display: inline-block;
  position: relative;
  width: 20px;
  height: 20px;
  border: 2px solid dimgray;
  border-radius: 30px 30px 30px 0;
  transform: rotate(-45deg);
}
.location:before {
  content: &amp;quot;&amp;quot;;
  position: absolute;
  width: 8px;
  height: 8px;
  background-color:dimgray;
  border: 2px solid dimgray;
  border-radius: 7px;
  top:4px;
  left:4px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;■虫眼鏡マーク&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;div class=&amp;quot;glass&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSS"&gt;.glass {
  display: inline-block;
  position: relative;
  width: 15px;
  height: 15px;
  border: 3px solid dimgray;
  border-radius: 20px;
}
glass:before {
  content: &amp;quot;&amp;quot;;
  position: absolute;
  width: 4px;
  height: 14px;
  background-color: dimgray;
  border-radius: 5px;
  top: 14px;
  left: 14px;
  transform: rotate(-35deg);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;■スイッチ&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;div class=&amp;quot;Switch&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-CSS"&gt;.Switch {
  position: relative;
  width: 20px;
  height: 42px;
  background: #ccc;
}
.Switch:before {
  content: '';
  position: absolute;
  width: 12px;
  height: 32px;
  left: 4px;
  top: 4px;
  background: #fff;
}
.Switch:after {
  content: '';
  position: absolute;
  width: 12px;
  height: 12px;
  left: 4px;
  top: 4px;
  background: #596;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="span"&gt;spanでの図形表示&lt;/h2&gt;
&lt;p&gt;divを使うと前後に改行が入ります。&lt;br /&gt;
改行させたくない場合は、&amp;lt;span&amp;gt;を使用します。&lt;/p&gt;
&lt;p&gt;その場合、cssに&amp;quot;display: inline-block;&amp;quot;を追加すると、divと同じように図形を表示させることができます。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="url"&gt;参考URL&lt;/h2&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://qiita.com/yaegaki/items/a1e518d16be9b85479b4"&gt;qiita CSSで作図する&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://morobrand.net/mororeco/web/css/css-shape/"&gt;CSSでいろんなカタチを表現してみる&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://saruwakakun.com/html-css/basic/before-after"&gt;CSSの疑似要素とは？beforeとafterの使い方まとめ&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>python 仮想環境の作り方</title>
			<link>https://yamaccu.github.io/posts/20210820-python-pipenv</link>
			<description>&lt;p&gt;pythonでプログラミングする際の、仮想環境の構築についてまとめています。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210820-python-pipenv</guid>
			<pubDate>Fri, 20 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;pythonでプログラミングする際の、仮想環境の構築についてまとめています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;仮想環境について&lt;/h2&gt;
&lt;p&gt;Pythonでプログラミングを行う際には、作るプログラムごとに仮想環境を構築します。&lt;/p&gt;
&lt;p&gt;理由は、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仮想環境ごとに必要なパッケージのバージョンをインストールできます。&lt;/li&gt;
&lt;li&gt;パッケージが複数のプログラムへ影響を与えるなどの、各プログラム間の干渉を回避できます。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仮想環境の作成にはいくつか方法がありますが、ここではpipenvを使用します。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;h2 id="section-1"&gt;仮想環境の作成手順&lt;/h2&gt;
&lt;p&gt;コマンドプロンプトを使います。&lt;/p&gt;
&lt;p&gt;① pipenvをインストールします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip install pipenv
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;②作業ディレクトリを作成します。&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;③作業ディレクトリに移動して、必要なパッケージをpipenvコマンドでインストールします。&lt;br /&gt;
（pipfileという設定ファイルが作成され、ここに仮想環境の情報が入ります。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pipenv install xxxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;④仮想環境を実行します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pipenv shell
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;⑤仮想環境を終了します。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exit
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;※仮想環境に入らずにコマンド実行もできます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pipenv run xxxxxx
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="hp"&gt;参考HP&lt;/h2&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://pipenv.pypa.io/en/latest/"&gt;pipenv公式&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>Github pushまでの設定</title>
			<link>https://yamaccu.github.io/posts/20210819-git-push</link>
			<description>&lt;p&gt;githubのレポジトリにpushするまでの設定をまとめています。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210819-git-push</guid>
			<pubDate>Thu, 19 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;githubのレポジトリにpushするまでの設定をまとめています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;認証方法&lt;/h2&gt;
&lt;p&gt;githubの認証には、&amp;quot;HTTP&amp;quot;と&amp;quot;SSH&amp;quot;の2種類あります。
ここでは、SSHの方法を記載します。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section-1"&gt;準備&lt;/h2&gt;
&lt;p&gt;以下が済んでいる必要があります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gitのインストール&lt;/li&gt;
&lt;li&gt;githubへのサインアップ&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="ssh"&gt;端末のSSH公開鍵の設定&lt;/h2&gt;
&lt;p&gt;git bushでSSH公開鍵を生成します。
下記のコマンドで生成できます。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;githubのページにサインインし、Setting =&amp;gt; SSH and GPG keys で生成したSSH鍵を登録します。&lt;/p&gt;
&lt;img src="../img/20210819-Git-push-1.png" width="85%"&gt;
&lt;br&gt;
&lt;br&gt;
 
&lt;h2 id="section-2"&gt;ローカル環境設定&lt;/h2&gt;
&lt;p&gt;git bushで下記のコマンドを実行して、ローカル環境設定を行います。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;ユーザー名&amp;quot;
git config --global user.email &amp;quot;メールアドレス&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ユーザー名、メールアドレスはgithubの登録情報と同じものです。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="github"&gt;githubのレポジトリをクローン&lt;/h2&gt;
&lt;p&gt;githubのページでレポジトリ作成して、作成したレポジトリをローカル環境にクローンします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone &amp;lt;アドレス&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;このとき、アドレスはSSHのものにします。&lt;/p&gt;
&lt;img src="../img/20210819-Git-push-2.png" width="85%"&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="commitpush"&gt;commit＆push&lt;/h2&gt;
&lt;p&gt;ファイルの追加、修正をしたら、以下のコマンドでcommit＆pushします。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add &amp;lt;ファイル名&amp;gt;
git commit -m &amp;quot;コメント&amp;quot;
git push (-f) origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;※-fは強制プッシュなので取り扱い注意です&lt;/p&gt;
&lt;p&gt;※originの設定は、クローン時に自動で設定されます。&lt;/p&gt;
&lt;p&gt;※2020/10から、デフォルトブランチがmaster ⇒ main に変わりました。&lt;/p&gt;
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>micropythonにreplでアクセス</title>
			<link>https://yamaccu.github.io/posts/20210818-micropython-repl</link>
			<description>&lt;p&gt;micropythonにreplでアクセスする方法をまとめています。&lt;/p&gt;</description>
			<guid>https://yamaccu.github.io/posts/20210818-micropython-repl</guid>
			<pubDate>Wed, 18 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;micropythonにreplでアクセスする方法をまとめています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id="repl"&gt;replについて&lt;/h2&gt;
&lt;p&gt;repl：「Read（読み取り）、Eval（評価）、Print（印字）、Loop（ループ）」の頭字語です。&lt;/p&gt;
&lt;p&gt;micropython上でコマンドを実行できる仕組みで、コマンドプロンプトのようなイメージです。&lt;br /&gt;
コードをテストするときに、コマンドを一つずつ実行できるので便利です。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="section"&gt;アクセス方法&lt;/h2&gt;
&lt;p&gt;デバイスのシリアルポートに、シリアル通信アプリ（teratermなど）で接続します。&lt;br /&gt;
通信速度は115200bpsです。&lt;br /&gt;
CTR+Cを二回で、mainで実行している処理を中止してreplで操作可能になります。&lt;/p&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;h2 id="section-1"&gt;コマンド&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;コマンド&lt;/th&gt;
&lt;th&gt;内容&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;help()&lt;/td&gt;
&lt;td&gt;ヘルプを表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;help('modules')&lt;/td&gt;
&lt;td&gt;使用可能なライブラリを表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;help(obj)&lt;/td&gt;
&lt;td&gt;調べたいobjectの説明を表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dir()&lt;/td&gt;
&lt;td&gt;import済みのファイル情報の表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sys.path.append('パス')&lt;/td&gt;
&lt;td&gt;import時に探索されるパスを追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;os.listdir()&lt;/td&gt;
&lt;td&gt;カレントディレクトリのファイルを表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tabキー&lt;/td&gt;
&lt;td&gt;入力候補の表示&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2 id="url"&gt;参考URL&lt;/h2&gt;
&lt;p&gt;&lt;span class="link"&gt;&lt;/span&gt; &lt;a href="https://micropython-docs-ja.readthedocs.io/ja/latest/esp8266/tutorial/repl.html"&gt;micropython公式&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>